I will give you two code samples:

Code A:

from tree import Node
from time import sleep

def input_to_string(str):
    list = str.split(",")
    new_input = [[*i] for i in list]
    return new_input[::-1]

def create_tree(node: Node, turn):
    sleep(1)
    
    for i in range(0, 7):
        
        # new_node
        child = Node(turn, node.state)
        
        node.add_child(child, i)
        
        child.make_move(i)
        child.depth = node.depth + 1
        
        print(f"\nRe:{child.depth}\n")
        print(turn)
        for i in child.state:
            print(i)
    
        if child.root == False:
            if turn == 'r':
                create_tree(child, 'y')
            if turn == 'y':
                create_tree(child, 'r')
        
        

def connect_four_mm(contents, turn, max_depth):
    
    new_state = input_to_string(contents)
    
    if turn == 'yellow':
        turn = 'y'
    if turn == 'red':
        turn = 'r'

    head_node = Node(turn, new_state)
    
    create_tree(head_node, turn)

    return ''

Code B: class Node:
    
    root = False
    
    depth = 0
    player = 0
    score = 0
    children =        [0,0,0,0,0,0,0]
    parent = None
    
    state = [[".",".",".",".",".",".","."],
             [".",".",".",".",".",".","."],
             [".",".",".",".",".",".","."],
             [".",".",".",".",".",".","."],
             [".",".",".",".",".",".","."],
             [".",".",".",".",".",".","."]]
    
    def __init__(self, player, state):
        self.player = player
        self.score = self.SCORE(self.state, self.player)
        
        self.state = state
    
    def add_child(self, child, column):
        
        self.children[column] = child
        child.parent = self
        
    def UTILITY(self, state):
        if self.NUM_IN_A_ROW(self, state, 4, 'r') > 0:
            return 10000
        if self.NUM_IN_A_ROW(self, state, 4, 'y') > 0:
            return -10000
        
    def EVALUATION(self, state):
        return self.SCORE(state, 'r') - self.SCORE(state, 'y')

    def SCORE(self, state, player):
        val = self.count_tokens(state, player) + 10 * self.NUM_IN_A_ROW(state, 2, player) + 100 * self.NUM_IN_A_ROW(state, 3, player) + 1000 * self.NUM_IN_A_ROW(state, 4, player)
        return val
        
    def count_tokens(self, state, item):
        count = 0
        for row in state:
            for element in row:
                if element == item:
                    count += 1
        return count
    
    
    def NUM_IN_A_ROW(self, arr, n, char):

        count = 0
            
        # check rows
        for row in arr:
            consecutive_count = 0
            for i in range(len(row)):
                if row[i] == char:
                    consecutive_count += 1
                    if consecutive_count == n:
                        count += 1
                        consecutive_count = 0
                else:
                    consecutive_count = 0
        
        # check columns
        for j in range(len(arr[0])):
            consecutive_count = 0
            for i in range(len(arr)):
                if arr[i][j] == char:
                    consecutive_count += 1
                    if consecutive_count == n:
                        count += 1
                        consecutive_count = 0
                else:
                    consecutive_count = 0
        
        # check diagonals
        for i in range(len(arr)):
            for j in range(len(arr[0])):
                if i + n <= len(arr) and j + n <= len(arr[0]):
                    # check diagonal from top-left to bottom-right
                    consecutive_count = 0
                    for k in range(n):
                        if arr[i+k][j+k] == char:
                            consecutive_count += 1
                            if consecutive_count == n:
                                count += 1
                                consecutive_count = 0
                        else:
                            consecutive_count = 0
                            
                    # check diagonal from bottom-left to top-right
                    consecutive_count = 0
                    for k in range(n):
                        if arr[i+n-1-k][j+k] == char:
                            consecutive_count += 1
                            if consecutive_count == n:
                                count += 1
                                consecutive_count = 0
        
        if count != 0:
            
            if n == 2:
                count = count - self.NUM_IN_A_ROW(self, arr, 4, char)*3 - self.NUM_IN_A_ROW(self, arr, 3, char)*2
            if n == 3:
                count = count - self.NUM_IN_A_ROW(self, arr, 4, char)*2
        
        return count
    
    def make_move(self, column):
        
        for row in range(5, -1, -1):
            if self.state[row][column] == '.':
                self.state[row][column] = self.player
                self.check_full()
                return
        
    def check_full(self):
        for row in self.state:
            for element in row:
                if element == '.':
                    self.root = False
                    return
                    
        self.root = True







if __name__ == '__main__':
    # Example function call below, you can add your own to test the connect_four_mm function
    connect_four_mm(".......,.......,.......,.......,.......,.......", "red", 1)

From these two code samples, I am getting the response:

Re:7

r
['y', '.', '.', '.', '.', '.', '.']
['r', '.', '.', '.', '.', '.', '.']
['y', '.', '.', '.', '.', '.', '.']
['r', '.', '.', '.', '.', '.', '.']
['y', '.', '.', '.', '.', '.', '.']
['r', '.', '.', '.', '.', '.', '.']

While I want to get this
Re:7

r
['y', '.', '.', '.', '.', '.', '.']
['r', '.', '.', '.', '.', '.', '.']
['y', '.', '.', '.', '.', '.', '.']
['r', '.', '.', '.', '.', '.', '.']
['y', '.', '.', '.', '.', '.', '.']
['r', 'r', '.', '.', '.', '.', '.']